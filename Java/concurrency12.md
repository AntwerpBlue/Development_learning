# Java 并发编程

## Lecture 12: ReadWriteLock

读写锁是一种特殊的锁，允许多个读操作并发执行，但写操作必须独占访问。

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock readLock = rwLock.readLock();
Lock writeLock = rwLock.writeLock();

// 读操作
readLock.lock();
try {
    // 执行读操作
} finally {
    readLock.unlock();
}

// 写操作
writeLock.lock();
try {
    // 执行写操作
} finally {
    writeLock.unlock();
}
```

### 基本规则

- **共享-独占规则：**
  - 读锁是共享锁（可被多个线程同时持有）
  - 写锁是独占锁（同一时间只能被一个线程持有）
- **读写互斥规则：**
  - 当写锁被持有时，所有读锁和其他写锁请求都必须等待
  - 当读锁被持有时，写锁请求必须等待
- **可重入规则：**
  - 同一个线程可以重复获取同一把读锁或写锁，但必须成对释放

### 获取规则

- **读锁：**
  - 无写锁：没有线程持有写锁
  - 无写等待：没有线程正在等待获取写锁（取决于公平性策略）
  - 当前线程：即使当前线程持有写锁，也可以获取读锁（锁降级特例）
- **写锁：**
  - 无任何锁：没有任何线程持有读锁或写锁
  - 持有者为当前线程：允许写锁重入（当前线程已持有写锁时）

### 特殊规则

- **锁降级：**
  - 允许持有写锁的线程获取读锁，然后释放写锁
  - 可以保证数据可见性同时允许其他读操作
  - 示例：

    ```java
    writeLock.lock();
    try {
        // 修改数据
        readLock.lock();  // 锁降级
    } finally {
        writeLock.unlock();
    }
    // 此时仍持有读锁
    ```

- **锁升级：**
  - 不允许直接从读锁升级到写锁
  - 必须先释放所有读锁，再获取写锁
  - 可能导致死锁（读锁等待写锁释放，写锁等待读锁释放）

### 读锁插队

在非公平模式下，允许新到达的读锁请求越过等待队列中的写锁直接获取锁，在设计上出于以下原因：

- **性能优化：**
  - 读操作通常比写操作频繁且耗时短
  - 避免了不必要的线程挂起/唤醒操作
  - 允许并发读可以显著提高系统吞吐量
- **现实场景：**
  - 在许多实际应用中，读操作远多于写操作
  - 短暂的写阻塞通常可以接受
  - 读操作的快速响应更重要

但插队也有可能引发写锁饥饿，如果读锁持续到达，写请求将一直无法获取锁。解决方案包括：

- 设置最大等待时间
- 适用公平锁模式
