# Java 并发编程

## Lecture 13: JVM的锁优化

### 偏向锁（Biased Locking）

**优化目标**：消除无竞争情况下的同步开销

**实现原理**：

- 当锁第一次被线程获取时，JVM会记录线程ID（"偏向"该线程）
- 该线程后续获取锁时不需要任何同步操作
- 只有当其他线程尝试获取锁时，才会撤销偏向状态

**适用场景**：单线程重复获取锁的情况

### 轻量级锁（Lightweight Locking）

**优化目标**：减少无竞争或低竞争时的锁开销

**实现原理**：

- 使用CAS操作实现锁获取
- 在对象头中存储锁记录指针
- 如果CAS成功，线程获得锁；如果失败，升级为重量级锁

**特点**：

- 不涉及系统互斥量
- 适合锁持有时间短的场景

### 自旋优化（Spin Locking）

**优化目标**：减少线程阻塞/唤醒的开销

**实现原理**：

- 当轻量级锁竞争失败时，线程不立即阻塞
- 执行有限次数的空循环（自旋）尝试获取锁
- 自旋失败后再挂起线程

**自适应调整**：

- JVM会根据历史成功率动态调整自旋次数
- 对于经常自旋成功的锁会增加自旋时间
- 对于很少成功的锁会减少或跳过自旋

### 锁消除（Lock Elision）

**优化目标**：消除不必要的同步操作

**实现原理**：

- 通过逃逸分析判断锁对象不会逃逸当前方法/线程
- 将同步代码块的锁操作完全移除

### 锁粗化（Lock Coarsening）

**优化目标**：减少锁的粒度，降低锁竞争

**实现原理**：

- 将相邻的多个同步块合并为一个更大的同步块
- 减少锁的获取和释放次数

### 总结

- 乐观锁&悲观锁
  - 悲观锁：假设冲突，使用互斥量保护后操作
  - 乐观锁：假设无冲突，操作后使用CAS判断
- 重量级锁&轻量级锁
  - 重量级锁：悲观锁的一种实现方式，加锁解锁需要OS支持，开销大，适用于高竞争场景
  - 轻量级锁：乐观锁的一种实现方式，加锁解锁开销小，适用于低竞争场景
- 挂起等待锁&自旋等待锁
  - 挂起等待锁：重量级锁的典型实现，线程阻塞后由OS唤醒，等待过程中不消耗CPU资源
  - 自旋等待锁：轻量级锁的典型实现，等待过程中不放弃CPU，锁被释放后第一时间获取锁
- 普通互斥锁&读写锁
  - 普通互斥锁：读写操作都互斥
  - 读写锁：多线程间读操作不会产生线程安全问题，因此设计读写锁在操作时表明意图，读操作不互斥，写操作与任何线程互斥
- 可重入锁&不可重入锁
  - 可重入锁：允许同一个线程多次获得同一把锁，Java中Reentrant锁、Lock实现类、synchronized都是可重入的
  - 不可重入锁：Linux提供的mutex是不可重入锁
- 公平锁&非公平锁
  - 公平锁：先来后到，需要借助额外的数据结构记录线程顺序
  - 非公平锁：不保证顺序，OS中线程调度本质上是随机的，默认为非公平锁
