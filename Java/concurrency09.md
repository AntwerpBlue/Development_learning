# Java 并发编程

## Lecture 9: 锁

### 悲观锁与乐观锁

悲观锁和乐观锁是两种不同的**并发控制策略**，其本质区别在于对数据竞争可能性的**预设态度**和**实现机制**。

#### 悲观锁（Pessimistic Locking）

- 假定并发冲突一定会发生，因此**提前加锁**，确保独占访问。核心思想是“先保护，后操作”（宁可不做，也不能错）。
- 特点：
  - **阻塞式**：其他线程必须等待锁释放
  - **一致性高**：严格避免脏读、幻读等问题
  - **开销大**：锁竞争会引发线程挂起/唤醒（上下文切换）
- 适用场景：
  - **写多读少**：冲突概率高的场景（如银行转账、库存扣减）
  - **长事务**：需要长时间持有锁的操作

#### 乐观锁（Optimistic Locking）

- 假定并发冲突很少发生，因此**不加锁**，只在提交时检测冲突。核心思想是“先操作，后判断”（乐观尝试，冲突时重试或放弃）。
- 特点：
  - **非阻塞式**：线程无需等待锁释放，冲突时重试或放弃
  - **轻量级**：无锁竞争时的上下文切换
  - **冲突需处理**：需要设计重试机制或业务回滚
- 适用场景：
  - **读多写少**：冲突概率低的场景（如商品浏览、评论查看）
  - **短平快操作**：简单变量的原子更新

### 公平锁与非公平锁

- 公平锁（Fair Lock）：多个线程按照申请锁的顺序来获取锁，类似于排队，先到先得。当锁释放时，等待时间最长的线程会优先获得锁。
- 非公平锁（Non-Fair Lock）：非公平锁允许"插队"行为，当锁可用时，所有等待线程都有机会竞争锁，而不管它们等待的时间长短。新请求锁的线程可能会立即获得锁，即使有其他线程已经在等待。

#### 为什么需要非公平锁

- **性能提升**：非公平锁减少了线程切换的开销。当锁释放时，新来的线程可能立即获取锁，而不需要唤醒等待线程。而公平锁需要维护一个有序队列，增加了系统开销。
- **减少上下文切换**：公平锁可能导致频繁的线程挂起和唤醒，产生大量上下文切换；非公平锁允许线程在尝试获取锁失败后再进入等待状态，减少了不必要的线程状态转换。
- **现实场景适用性**：在实际应用中，短暂的锁持有时间下，非公平锁的性能通常优于公平锁。大多数情况下，线程获取锁的顺序并不重要，重要的是系统整体吞吐量。

#### 适用场景

- 使用公平锁：
  - 当线程等待时间差异较大时
  - 需要避免线程饥饿的情况
  - 对顺序性有严格要求的场景
- 使用非公平锁：
  - 追求高吞吐量
  - 锁持有时间短
  - 线程竞争不激烈时

#### 实现方式

- 公平锁：在获取锁时，检查是否有其他线程在等待，如果有则排队等待。
- 非公平锁：
  - 直接尝试获取锁：首先不检查是否有等待队列，直接尝试通过CAS操作获取锁。如果成功，立即获取锁并继续执行；如果失败，则进入排队流程。
  - 排队后再次尝试：即使进入排队状态后，在真正挂起前，仍然会尝试一次获取锁。
  - 之后进入AQS（AbstractQueuedSynchronizer）等待，只有队首节点被允许尝试获取锁，其他节点被挂起等待前驱节点唤醒。
